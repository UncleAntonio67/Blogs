🏷中等 #数组 #动态规划 

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**请注意**，一个只包含一个元素的数组的乘积是这个元素的值。

**示例 1:**

>**输入:** `nums = [2,3,-2,4]`
>**输出:** `6`
>**解释:** `子数组 [2,3] 有最大乘积 6。`

**示例 2:**
>**输入:** `nums = [-2,0,-1]`
>**输出:** `0`
>**解释:** `结果不能为 2, 因为 [-2,-1] 不是子数组。`

**提示:**

- `1 <= nums.length <= 2 * 104`
- `-10 <= nums[i] <= 10`
- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位** 整数

## 解题思路

相乘遇到负数会反转大小，所以必须同时维护“以 i 结尾的最大乘积”和“最小乘积”，当前状态来自：自己开新段、前最大 × 当前、前最小 × 当前，三者取 min/max。

| **维度**    | **详细分析**                                                                                                                                                                            |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **动态规划 (状态机)**。<br>由于存在负数，当前的最大值可能由“之前的最大值 $\times$ 正数”得来，也可能由“之前的最小值 $\times$ 负数”得来。<br><br>因此必须同时记录：<br>1. `dp_max[i]`：以 $i$ 结尾的乘积最大值。<br>2. `dp_min[i]`：以 $i$ 结尾的乘积最小值（为了翻盘做准备）。 |
| **代码评价**  | 1. **逻辑完备**：`max(x, pre_max*x, pre_min*x)` 这行代码涵盖了所有情况（正数增益、负负得正、断开重开）。<br>2. **细节**：使用了 `nums[:]` 进行拷贝，避免了引用修改问题。                                                                  |
| **时间复杂度** | **$O(N)$**。<br>一次遍历。                                                                                                                                                                |
| **空间复杂度** | **$O(N)$**。<br>使用了两个数组。其实这道题和“爬楼梯”一样，可以优化成 $O(1)$，只用两个变量 `current_max` 和 `current_min` 滚动更新。                                                                                        |
## 方法一：

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        dp_max = nums[:]
        dp_min = nums[:]

        for i in range(1,n):
            x = nums[i]
            pre_max = dp_max[i-1]
            pre_min = dp_min[i-1]

            dp_max[i] = max(x, pre_max*x, pre_min*x)
            dp_min[i] = min(x, pre_max*x, pre_min*x)
        return max(dp_max)
```