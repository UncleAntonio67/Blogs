🏷中等 #数组 #哈希表 #分治 #桶排序 #计数 #快速选择 #排序 #堆（优先队列）

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1：**

>**输入：`nums = [1,1,1,2,2,3], k = 2`
>**输出：**`[1,2]`

**示例 2：**

>**输入：`nums = [1], k = 1`
>**输出：**`[1]`

**示例 3：**

>**输入：`nums = [1,2,1,2,1,2,3,1,3,2], k = 2`
>输出：**`[1,2]`

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：你所设计算法的时间复杂度 必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

# 解题思路与实现

- 哈希表
- 小顶堆

| **维度**      | **分析内容**                                                                                                                                                                           |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**    | **哈希统计 + 限制容量的最小堆**。<br><br>1. **频率统计**：使用 `Counter` 快速计算每个元素的出现次数。<br>2. **频率优先堆**：将 `(count, num)` 元组存入堆。Python 的元组比较默认从第一个元素（即频率）开始。<br>3. **动态淘汰**：一旦堆的大小超过 $k$，弹出当前堆中频率最小的元素。 |
| **为什么用最小堆** | 要找前 $k$ 个**最高**频率，我们需要剔除掉低频。最小堆的堆顶是最小值，方便我们像“末位淘汰制”一样不断扔掉频率最低的元素。                                                                                                                  |
| **时间复杂度**   | $O(N \log k)$<br>$N$ 是数组长度。统计频率需 $O(N)$，遍历哈希表并维护大小为 $k$ 的堆需 $O(M \log k)$（$M$ 为去重后的元素个数）。                                                                                          |
| **空间复杂度**   | $O(N)$<br>主要消耗在 `Counter` 存储频率映射上。                                                                                                                                                 |
## 方法一：

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dict = {}
        for num in nums:
            if num in dict.keys():
                dict[num] += 1
            else:
                dict[num] = 1
        topk = sorted(dict.items(), key=lambda x: x[1], reverse=True)[:k]
        return [row[0] for row in topk]
```

## 方法二：

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        freq = Counter(nums)
        heap = []
        for num, count in freq.items():
            heapq.heappush(heap, (count, num))
            if len(heap) > k:
                heapq.heappop(heap)

        return [num for count,num in heap]
```