ğŸ·ç®€å• #æ ‘ #æ·±åº¦ä¼˜å…ˆæœç´¢ #äºŒå‰æ ‘ 

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘Â `root`Â ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚

äºŒå‰æ ‘çš„Â **æœ€å¤§æ·±åº¦**Â æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

**ç¤ºä¾‹ 1ï¼š**

![|300 ](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š3
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šroot = [1,null,2]
è¾“å‡ºï¼š2

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹çš„æ•°é‡åœ¨Â `[0, 104]`Â åŒºé—´å†…ã€‚
- `-100 <= Node.val <= 100`

# è§£é¢˜æ€è·¯ä¸å®ç°

- é€’å½’
- è¿­ä»£

## æ–¹æ³•ä¸€ï¼šé€’å½’

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        return max(left_depth, right_depth) + 1
```

## æ–¹æ³•äºŒï¼šè¿­ä»£

```python 
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        queue = deque([root])
        depth = 0
        while queue:
            level_size = len(queue)
            for _ in range(level_size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            depth += 1
        return depth
```