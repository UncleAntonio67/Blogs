🏷简单 #数学 #动态规划 

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：

>输入：`n = 2`
>输出：`2`
>解释：`有两种方法可以爬到楼顶。`

示例 2：

>输入：`n = 3`
>输出：`3`
>解释：`有三种方法可以爬到楼顶。`

**提示：**
- `1 <= n <= 45`

# 解题思路与实现

- 正向循环迭代，f(n) = f(n-1) + f(n-2)
- 只需要两个变量 `p` 和 `q` 来记录前两步的状态，像滚轮一样不断向前滚动。

| **维度**    | **迭代+数组**                        | **滚动变量**                     |
| --------- | -------------------------------- | ---------------------------- |
| **核心思路**  | `f[i] = f[i-1] + f[i-2]`         | `current = prev + prev_prev` |
| **空间复杂度** | **$O(n)$**<br>如果不必要的开辟数组，面试官会扣分。 | **$O(1)$**<br>仅占用常数空间，最优解。   |
| **时间复杂度** | $O(n)$                           | $O(n)$                       |

## 方法一：迭代法

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        f= [0]*(n+1)
        f[0] = f[1] = 1
        for i in range(2,n+1):
            f[i] = f[i-2] + f[i-1]
        return f[n]  
```

## 方法二：**滚动变量**
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        # 基础边界
        if n <= 1: 
            return 1
        # p 代表 f[i-2], q 代表 f[i-1]
        p, q = 1, 1
        for _ in range(2, n + 1):
            # 新的当前层 = 前两层之和
            # 然后状态整体前移：旧的 q 变成新的 p，和变成新的 q
            p, q = q, p + q
            
        return q
```