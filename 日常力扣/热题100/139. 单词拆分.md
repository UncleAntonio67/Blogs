🏷中等 #字典树 #记忆化搜索 #数组 #哈希表 #字符串 #动态规划

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

>**输入:** `s = "leetcode", wordDict = ["leet", "code"]`
>**输出:** `true`
>**解释:** `返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。`

**示例 2：**

>**输入:** `s = "applepenapple", wordDict = ["apple", "pen"]`
>**输出:** `true`
>**解释:** `返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。注意，你可以重复使用字典中的单词。`

**示例 3：**

>**输入:** `s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]`
>**输出:** `false`

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

## 解题思路

- “`dp[i]` 表示一个前缀是否可行，枚举所有切割点 j，看 j 之前可行且 j 到 i 是字典词。”

| **维度**    | **详细分析**                                                                                                                                                                                                                                                |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **动态规划 (DP)**。<br>定义 `dp[i]` 表示字符串的前 `i` 个字符 `s[0:i]` 是否能被拆分成字典里的单词。<br>状态转移：如果存在一个分割点 `j` ($0 \le j < i$)，使得 `dp[j]` 为真（前 `j` 个能拆分）且 `s[j:i]` 也在字典里，那么 `dp[i]` 为真。<br>方程：$dp[i] = \text{True, if } \exists j: dp[j] \land s[j:i] \in \text{word\_set}$ |
| **代码评价**  | 1. **哈希优化**：正确使用了 `set` 加速查找。<br>2. **DP 定义**：`n = len(s) + 1` 和 `dp[0] = True` 的初始化非常标准。<br>3. **逻辑闭环**：`break` 的使用很好（只要找到一种切分方式让 `dp[i]` 为真，就不需要继续找了，节省时间）。                                                                                           |
| **时间复杂度** | **$O(L^2)$**。<br>$L$ 是字符串长度。两层循环。外层遍历 $L$，内层遍历 $i$。虽然切片 `s[j:i]` 也有开销，但在面试中通常认为是 $O(L^2)$ 或 $O(L^3)$（取决于字符串切片和哈希实现的具体复杂度）。                                                                                                                              |
| **空间复杂度** | **$O(L)$**。<br>用于存储 `dp` 数组。                                                                                                                                                                                                                            |
## 方法一：

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        word_set = set(wordDict)
        n = len(s)
        dp = [False] *(n+1)
        dp[0] = True
        for i in range(1,n+1):
            for j in range(i):
                if dp[j] and s[j:i] in word_set:
                    dp[i] = True
                    break 
        return dp[n]
        
```