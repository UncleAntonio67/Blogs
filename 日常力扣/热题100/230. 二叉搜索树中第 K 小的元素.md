🏷中等 #树 #深度优先搜索 #二叉搜索树 #二叉树 

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

**示例 1：**

![|150](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

输入：root = [3,1,4,null,2], k = 1
输出：1

**示例 2：**

![250](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3

**提示：**

- 树中的节点数为 `n` 。
- `1 <= k <= n <= 104`
- `0 <= Node.val <= 104`

**进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？


# 解题思路与实现

- 递归法
- 迭代法

| **维度**    | **递归解法 **                                           | **迭代解法 (推荐掌握)**              |
| --------- | --------------------------------------------------- | ---------------------------- |
| **核心思路**  | 利用中序遍历性质，维护全局变量 `count` 和 `res`，在递归到第 $k$ 个节点时记录结果。 | 使用显式栈进行中序遍历，弹出第 $k$ 个元素即为答案。 |
| **时间复杂度** | $O(H + k)$，$H$ 为树高。最坏情况 $O(n)$。                     | $O(H + k)$，找到即停。             |
| **空间复杂度** | $O(H)$，递归调用的栈空间。                                    | $O(H)$，显式栈的空间。               |
| **优化点**   | 引入 `self.res is not None` 实现了快速失败。                  | 逻辑更直观，不需要全局变量，面试官通常更喜欢。      |

## 方法一：递归

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.count = 0
        self.res = None

        def inorder(node):
            if not node or self.res is not None:
                return
            inorder(node.left)
            self.count += 1
            if self.count == k:
                self.res = node.val
                return
            inorder(node.right)
        inorder(root)
        return self.res
```

## 方法二：迭代

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        stack = []
        cur = root
        
        while cur or stack:
            # 1. 尽可能向左走，将路径上的节点全部入栈
            while cur:
                stack.append(cur)
                cur = cur.left
            
            # 2. 弹出栈顶元素（当前最小的元素）
            cur = stack.pop()
            k -= 1
            
            # 3. 检查是否是第 k 个
            if k == 0:
                return cur.val
            
            # 4. 转向右子树
            cur = cur.right
```