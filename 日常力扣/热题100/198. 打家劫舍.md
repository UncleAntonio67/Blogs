🏷中等 #数组 #动态规划 

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

示例 1：

>输入：`[1,2,3,1]`
>输出：`4`
>解释：`偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。`

示例 2：

>输入：`[2,7,9,3,1]`
>输出：`12`
>解释：`偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。`

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

# 解题思路与实现

- 每个房子只有偷或不偷两种决策，当前最优由前两间房的最优状态决定 → 用 DP 解决。

| **维度**    | **详细分析**                                                                                                                                                                                                                                                    |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **动态规划 (DP)** + **滚动变量优化**。<br>对于第 $i$ 间房子，只有两种选择：<br>1. **偷**：如果你偷第 $i$ 间，就不能偷第 $i-1$ 间，总金额 = `nums[i] + dp[i-2]`。<br>2. **不偷**：如果你不偷第 $i$ 间，由于我们要最大利润，意味着我们保持第 $i-1$ 间的最大收益，总金额 = `dp[i-1]`。<br>状态转移方程：$dp[i] = \max(dp[i-2] + \text{nums}[i], dp[i-1])$。 |
| **代码对应**  | `a` 代表 $dp[i-2]$ (前前一家最大值)。<br>`b` 代表 $dp[i-1]$ (前一家最大值)。<br>`c = max(a + nums[i], b)` 完美对应了状态转移方程。                                                                                                                                                         |
| **时间复杂度** | **$O(N)$**。<br>只遍历了一次数组。                                                                                                                                                                                                                                    |
| **空间复杂度** | **$O(1)$**。<br>仅使用了 `a`, `b`, `c` 三个变量，没有使用额外的数组来存储历史状态。这是最优解。                                                                                                                                                                                              |


## 方法一：

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        a,b = nums[0],max(nums[0],nums[1])
        for i in range(2,len(nums)):
            c = max(b, a + nums[i])
            a = b
            b = c
        return b
```