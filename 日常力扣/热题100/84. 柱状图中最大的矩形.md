🏷困难 #栈 #数组 #单调栈 

给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![| 300](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

>输入：`heights = [2,1,5,6,2,3]`
>输出：`10`
>解释：`最大的矩形为图中红色区域，面积为 10`

**示例 2：**

![| 100](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

>**输入：** `heights = [2,4]`
>**输出：** `4`

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

# 解题思路与实现

解决这道题最有效的方法是使用**单调栈**。核心思想是：

对于柱状图中的**任意一个柱子 $i$**，如果它作为所求最大矩形中的**高度**，那么这个矩形的宽度 $W$ 必须满足：
1. 矩形的高度 $H = \text{heights}[i]$。
2. 矩形向左延伸到的边界 $L$ 是**第一个高度小于 $\text{heights}[i]$ 的柱子**的索引 $+1$。
3. 矩形向右延伸到的边界 $R$ 是**第一个高度小于 $\text{heights}[i]$ 的柱子**的索引 $-1$。
4. 最大宽度 $W = R - L + 1$。
5. 以 $\text{heights}[i]$ 为高的最大矩形面积 $A = \text{heights}[i] \times W$。

单调栈（本题中使用**单调递增栈**）正是用来高效地找到每个柱子左右两侧**第一个小于它的元素**的位置。

| **维度**    | **分析内容**                                                                                                                                                                       |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **核心思路**  | **寻找每个柱子作为“最短板”能向左右延伸的最远距离**。<br>1. **单调递增栈**：栈内存储索引，对应的柱子高度保持单调递增。<br>2. **触发计算**：当遇到比栈顶小的柱子时，说明栈顶柱子无法再向右延伸了。<br>3. **确定边界**：弹出栈顶作为矩形的高 $H$，此时**新的栈顶**就是左边界，**当前 $i$** 就是右边界。 |
| **哨兵技巧**  | 1. **`-1` 哨兵**：确保计算宽度 $W = i - stack[-1] - 1$ 时，即使弹出的是栈中最后一个元素，也能正确计算从索引 $0$ 开始的宽度。<br>2. **末尾 `0` 哨兵**：强制在遍历结束时弹出栈中所有剩余的柱子，触发最后的面积计算。                                         |
| **时间复杂度** | $O(N)$<br>每个柱子索引仅入栈一次、出栈一次。                                                                                                                                                    |
| **空间复杂度** | $O(N)$<br>最坏情况下栈的大小等于数组长度。                                                                                                                                                     |
## 方法一：

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = [-1]
        max_area = 0
        heights.append(0)
        for i,h in enumerate(heights):
            while stack[-1] != -1 and heights[stack[-1]] >= h:
                height_index = stack.pop()
                H = heights[height_index]
                W = i - stack[-1] -1
                max_area = max(max_area, H * W)
            stack.append(i)

        return max_area
```