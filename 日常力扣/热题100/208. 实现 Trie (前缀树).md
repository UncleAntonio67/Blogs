**Tire**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

>输入：`["Trie", "insert", "search", "search", "startsWith", "insert", "search"]`
>`[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]`
>输出：`[null, null, true, false, true, null, true]`

**解释**
`Trie trie = new Trie();`
`trie.insert("apple");`
`trie.search("apple");   // 返回 True`
`trie.search("app");     // 返回 False`
`trie.startsWith("app"); // 返回 True`
`trie.insert("app");`
`trie.search("app");     // 返回 True`

**提示：**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 104` 次



# 解题思路与实现

- 嵌套字典

| **维度**    | **分析内容**                                                                                                                                          |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **利用字符串的公共前缀来减少查询时间，提高效率。**<br>1. 每个节点是一个字典，键是字符，值是下一个节点。<br>2. 使用特殊标记 `"#"` (End of Word) 来区分“前缀”和“完整的单词”。<br>3. 插入和查询时，像走迷宫一样根据字符一级级深入。         |
| **空间复杂度** | $O(T \times \Sigma)$<br>其中 $T$ 是所有插入字符的总数，$\Sigma$ 是字符集大小（如 26 个字母）。<br>虽然最坏情况开销大，但当单词有大量公共前缀时，空间利用率极高。                                           |
| **时间复杂度** | **插入/查询/前缀搜索：** $O(L)$<br>其中 $L$ 是目标字符串的长度。查询速度与树中存储的单词总量无关，只与当前查询单词的长度有关，极其高效。                                                                   |
| **优点**    | 1. **前缀匹配**：这是哈希表（Hash Table）做不到的，Trie 可以极快地找到所有以 "pre" 开头的单词。<br>2. **有序性**：节点按字符排列，方便进行按字典序的搜索。<br>3. **结构清晰**：你使用的嵌套字典法避免了定义复杂的 Node 类，代码非常精简。 |

## 方法一：字典

```python
class Trie:

    def __init__(self):
        self.root = {}
 
    def insert(self, word: str) -> None:
        node = self.root
        for ch in word:
            if ch not in node:
                node[ch] = {}
            node = node[ch]
        node["#"] = True

    def search(self, word: str) -> bool:
        node = self.root
        for ch in word:
            if ch not in node:
                return False
            node = node[ch]
        return '#' in node
        

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for ch in prefix:
            if ch not in node:
                return False
            node = node[ch]
        return True
```