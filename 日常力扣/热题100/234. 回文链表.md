ğŸ·ç®€å• #æ ˆ #é€’å½’ #é“¾è¡¨ #åŒæŒ‡é’ˆ 

ç»™ä½ ä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹Â `head`Â ï¼Œè¯·ä½ åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚å¦‚æœæ˜¯ï¼Œè¿”å›Â `true`Â ï¼›å¦åˆ™ï¼Œè¿”å›Â `false`Â ã€‚

**ç¤ºä¾‹ 1ï¼š**

![|300](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

>**è¾“å…¥ï¼š`head = [1,2,2,1]`
>è¾“å‡ºï¼š`true`

**ç¤ºä¾‹ 2ï¼š**

![|150](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

>**è¾“å…¥ï¼š`head = [1,2]`
>è¾“å‡ºï¼š`false`

**æç¤ºï¼š**

- é“¾è¡¨ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´`[1, 105]`Â å†…
- `0 <= Node.val <= 9`

**è¿›é˜¶ï¼šä½ èƒ½å¦ç”¨Â `O(n)`Â æ—¶é—´å¤æ‚åº¦å’ŒÂ `O(1)`Â ç©ºé—´å¤æ‚åº¦è§£å†³æ­¤é¢˜ï¼Ÿ

## è§£é¢˜æ€è·¯ä¸å®ç°

- 1. å¤åˆ¶é“¾è¡¨å€¼åˆ°æ•°ç»„åˆ—è¡¨ä¸­ã€‚2. ä½¿ç”¨åŒæŒ‡é’ˆæ³•åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡ã€‚

| **ç‰¹æ€§**     | **æ–¹æ³•ä¸€ï¼šæ•°ç»„æ³• (Array/List)** | **æ–¹æ³•äºŒï¼šå¿«æ…¢æŒ‡é’ˆ + åè½¬ (Optimal)** |
| ---------- | ------------------------ | --------------------------- |
| **æ—¶é—´å¤æ‚åº¦**  | $O(n)$                   | $O(n)$                      |
| **ç©ºé—´å¤æ‚åº¦**  | **$O(n)$**               | **$O(1)$ (æœ€ä¼˜)**             |
| **å®ç°éš¾åº¦**   | æç®€                       | è¾ƒé«˜ï¼ˆæ¶‰åŠä¸­ç‚¹ã€åè½¬ã€å¯¹æ¯”ä¸‰æ­¥ï¼‰            |
| **å¯¹åŸæ•°æ®å½±å“** | æ— å½±å“                      | **æœ‰ç ´åæ€§**ï¼ˆååŠéƒ¨åˆ†è¢«åè½¬äº†ï¼‰          |
| **é€‚ç”¨åœºæ™¯**   | å¿«é€Ÿå®ç°ã€å¯¹å†…å­˜ä¸æ•æ„Ÿçš„åœºæ™¯           | é¢è¯•é«˜é¢‘è¦æ±‚ã€å†…å­˜ä¸¥æ ¼å—é™çš„åœºæ™¯            |

## æ–¹æ³•ä¸€ï¼šæ•°ç»„æ³•

```python
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        rec = []
        while head:
            rec.append(head.val)
            head = head.next
        return rec == rec[::-1]
```

## æ–¹æ³•äºŒï¼šå¿«æ…¢æŒ‡é’ˆ+åè½¬

```python
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        slow, fast = head,head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        pre = None
        cur = slow
        while cur:
            nex = cur.next
            cur.next = pre
            pre = cur
            cur = nex
        
        left, right = head, pre
        while right:
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        return True
```