🏷中等 #贪心 #数组 #动态规划 

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置在下标 0。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

**示例 1:**

>**输入:** `nums = [2,3,1,1,4]`
>**输出:** `2`
>**解释:** `跳到最后一个位置的最小跳跃数是 `2`。从下标为 0 跳到下标为 1 的位置，跳 `1` 步，然后跳 `3` 步到达数组的最后一个位置。`

**示例 2:**

>**输入:** `nums = [2,3,0,1,4]`
>**输出:** `2`

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `n - 1`

# 解题思路与实现

用 end 表示当前跳能到哪里；用 farthest 表示下一跳的最远范围。  
每当 i 走到 end，就必须跳一次，并更新 end = farthest。

| **维度**    | **方法一                                                                                     | **方法二                                                                                 |
| --------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **核心算法**  | **正向贪心 (BFS 思想)**                                                                         | **反向贪心 (回溯查找)**                                                                       |
| **核心思想**  | **“我知道每一步最远能到哪”**。<br>从左向右遍历，维护当前步数能覆盖的最远边界。一旦走到边界，就更新为新的最远边界，步数+1。                       | **“我要找谁能跳到我这里”**。<br>从终点开始，向左寻找能跳到当前位置的**最左侧**下标，将其设为新的目标点，步数+1，循环往复。                 |
| **核心代码**  | `farthest = max(farthest, i + nums[i])`<br>`if i == end:`<br>`jumps += 1; end = farthest` | `for i in range(position):`<br>`if i + nums[i] >= position:`<br>`position = i; break` |
| **时间复杂度** | **$O(n)$**<br>只需遍历数组一次，效率极高，适合超大规模数据。                                                     | **$O(n^2)$**<br>双重循环。最坏情况（如 `[1,1,1,1...]`）下，内层循环每次都要跑满，导致超时。                         |
| **空间复杂度** | **$O(1)$**<br>仅使用常数个变量。                                                                   | **$O(1)$**<br>仅使用常数个变量。                                                               |

## 方法一：

```python
class Solution:
    def jump(self, nums: list[int]) -> int:
        jumps = 0
        end = 0
        farthest = 0
        for i in range(len(nums) - 1):
            farthest = max(farthest, i+nums[i])
            if i == end:
                jumps += 1
                end = farthest
        return jumps
```

## 方法二：
```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        position = len(nums) - 1
        step = 0
        while(position != 0):
            for i in range(position):
                if i + nums[i] >= position:
                    position = i
                    step += 1
                    break
        return step
```