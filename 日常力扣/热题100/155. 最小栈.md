🏷中等 #栈 #设计 

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

>**输入：**
>`["MinStack","push","push","push","getMin","pop","top","getMin"]`
>`[[],[-2],[0],[-3],[],[],[],[]]`
>**输出：**
>`[null,null,null,null,-3,null,0,-2]`

**解释：**
>`MinStack minStack = new MinStack();`
>`minStack.push(-2);`
>`minStack.push(0);`
>`minStack.push(-3);`
>`minStack.getMin();   --> 返回 -3.`
>`minStack.pop();`
>`minStack.top();      --> 返回 0.`
>`minStack.getMin();   --> 返回 -2.`

**提示：**

- `-231 <= val <= 231 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次
## 解题思路

维护两个栈：
1. **stack**：正常存放所有元素
2. **min_stack**：每次 push 时，保存当前“栈内最小值”

| **维度**    | **分析内容**                                                                                                                                                                                   |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **核心思路**  | **空间换时间 (Auxiliary Stack)**。<br>1. **主栈 (`stack`)**：按正常顺序存储所有进入的元素。<br>2. **辅助栈 (`min_stack`)**：栈顶始终维护当前主栈内所有元素的**最小值**。<br>3. **同步策略**：只有当新值 $\le$ 当前最小值时才压入辅助栈；只有当弹出值 $=$ 当前最小值时才从辅助栈弹出。 |
| **关键点**   | `val <= self.min_stack[-1]`：这里的 **`<=`** 非常关键。如果有多个相同的最小值，必须全部记录在辅助栈中，否则弹出一个时会导致信息丢失。                                                                                                      |
| **时间复杂度** | **所有操作均为 $O(1)$**。<br>入栈、出栈、查看栈顶、获取最小值都不涉及遍历。                                                                                                                                              |
| **空间复杂度** | $O(n)$<br>在最坏情况下（元素递减），辅助栈的大小与主栈一致。                                                                                                                                                        |

## 方法一：

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)    

    def pop(self) -> None:
        val = self.stack.pop()
        if val == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

