🏷中等 #数组 #二分查找 

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **向左旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 下标 `3` 上向左旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

示例 1：

>输入：`nums = [4,5,6,7,0,1,2], target = 0`
>输出：`4`

示例 2：

>输入：`nums = [4,5,6,7,0,1,2], target = 3`
>输出：`-1`

示例 3：

>输入：`nums = [1], target = 0`
>输出：`-1`
 

**提示：**

- `1 <= nums.length <= 5000`
- `-104 <= nums[i] <= 104`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-104 <= target <= 104`


# 解题思路与实现

- **左半部分有序**（`nums[left] <= nums[mid]`）：
    - 如果目标值 `target` 在左半部分（`nums[left] <= target < nums[mid]`），则目标必定在左半部分，我们将 `right` 设置为 `mid - 1`，缩小搜索范围到左边。
    - 如果目标不在左半部分（即 `target` 大于等于 `nums[mid]`），说明目标在右半部分，我们将 `left` 设置为 `mid + 1`，缩小搜索范围到右边。
        
- **右半部分有序**（`nums[mid] < nums[right]`）：
    - 如果目标值 `target` 在右半部分（`nums[mid] < target <= nums[right]`），则目标必定在右半部分，我们将 `left` 设置为 `mid + 1`，缩小搜索范围到右边。
    - 如果目标不在右半部分（即 `target` 小于等于 `nums[mid]`），说明目标在左半部分，我们将 `right` 设置为 `mid - 1`，缩小搜索范围到左边。
        
- **无序部分的处理**：
    - 由于每次都会判断当前的部分是否有序，因此即使目标元素位于无序部分，也能在接下来的步骤中正确缩小搜索范围。只需要调整 `left` 或 `right`，确保我们继续在有序部分进行搜索。

| **维度**    | **分析内容**                                                                                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **核心思路**  | **分段二分查找**。<br>1. **确定有序段**：通过 `nums[left] <= nums[mid]` 判断左半段是否有序，否则右半段必然有序。<br>2. **范围判定**：在有序的那一段内，检查 `target` 是否在其数值范围内。<br>3. **区间收缩**：根据判定结果，将搜索范围缩小到有序段内或另一半无序段中。 |
| **关键条件**  | `nums[left] <= nums[mid]`：用于区分“旋转点”是在 `mid` 的左侧还是右侧。                                                                                                                     |
| **时间复杂度** | $O(\log N)$<br>尽管逻辑变复杂了，但每次依然排除了一半的元素。                                                                                                                                   |
| **空间复杂度** | $O(1)$<br>原地搜索，不占用额外空间。                                                                                                                                                  |

## 方法一：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```