ğŸ·ä¸­ç­‰ #æ ‘ #äºŒå‰æ ‘ #å¹¿åº¦ä¼˜å…ˆæœç´¢ 

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â `root`Â ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„Â **å±‚åºéå†**Â ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

**ç¤ºä¾‹ 1ï¼š**

![| 200](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[9,20],[15,7]]
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[[1]]
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´Â `[0, 2000]`Â å†…
- `-1000 <= Node.val <= 1000`


# è§£é¢˜æ€è·¯ä¸å®ç°

- é€’å½’
## æ–¹æ³•ä¸€ï¼šé€’å½’

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []

        def dfs(node,level):
            if not node:
                return
            if len(res) == level:
                res.append([])
            res[level].append(node.val)
            dfs(node.left, level+1)
            dfs(node.right, level+1)
        dfs(root,0)
        return res
```