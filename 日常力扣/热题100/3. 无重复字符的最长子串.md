🏷中等 #哈希表 #字符串 #滑动窗口

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。

**示例 1:**

**输入:** s = "abcabcbb"
**输出:** 3 
**解释:** 因为无重复字符的最长子串是 `"abc"`，所以其长度为 3。注意 "bca" 和 "cab" 也是正确答案。

**示例 2:**

**输入:** s = "bbbbb"
**输出:** 1
**解释:** 因为无重复字符的最长子串是 `"b"`，所以其长度为 1。

**示例 3:**

**输入:** s = "pwwkew"
**输出:** 3
**解释:** 因为无重复字符的最长子串是 `"wke"`，所以其长度为 3。
     请注意，你的答案必须是 **子串** 的长度，`"pwke"` 是一个_子序列，_不是子串。

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

# 解题思路与实现

- 最直接的想法就是借用空间存储无重复的字串，如果有重复，那么留下最大长度，同时字串剔除重复的字符，进一步进行遍历
- 可以利用数据的截取、in方法，节省空间存储
- 需要关注一个字符连续出现、非连续出现，对应无重复子串的起始位置

## 方法一：双指针法

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        i = j = 0
        res = 0
        if len(s) <= 1:
            return len(s)
        while j < len(s) - 1:
            j += 1
            if s[j] not in s[i:j]:
                if res < len(s[i:j+1]):
                    res = len(s[i:j+1])
            else:
                if j - i - 1 == 0:
                    i += 1
                else:
                    i = s[0:j].rindex(s[j]) + 1
        return max(1,res)
```