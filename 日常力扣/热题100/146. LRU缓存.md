🏷中等 #设计 #哈希表 #链表 #双向链表

请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

>**输入**
>`["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]`
>`[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]`
>**输出**
>`[null, null, null, 1, null, -1, null, -1, 3, 4]`

**解释**
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4


## 解题思路

- “OrderedDict 保顺序，get/put 都 move_to_end，超容量 pop 最旧。”
- `OrderedDict` 是 Python 标准库 `collections` 模块中的一个类，它是 **字典（dict）的一种子类**，与普通字典类似，但有一个关键特性：
	- **保持插入顺序**：在 Python 3.6 之后，普通字典在实现上也保持了插入顺序，但 `OrderedDict` 明确保证了顺序行为，并提供了一些额外的方法。

| **核心思路**  | **使用 HashMap 实现 O(1) 查找，使用 双向链表 维护访问顺序。新访问或新插入的节点移到链表头部，超出容量时删除链表尾部节点。**                                                                  |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **伪代码实现** | 1. 定义双向链表节点 Node；<br>2. `get(key)`: 若存在，通过 HashMap 找到 Node，移至 Head，返回 Val；<br>3. `put(key, val)`: 若存在则更新并移至 Head；若不存在且满员，删 Tail 再插入 Head。 |
| **时间复杂度** | $O(1)$ (Get 和 Put 操作均为常数时间)                                                                                                               |
| **空间复杂度** | $O(capacity)$ (需要存储最多 capacity 个节点)                                                                                                       |
## 方法一：OrderedDict🌟

```python
from collections import OrderedDict
class LRUCache:

    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.cap = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.cap:
            self.cache.popitem(last=False)
```