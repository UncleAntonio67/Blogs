🏷中等 #字符串 #动态规划 #回溯 

给你一个字符串 `s`，请你将 `s` 分割成一些 子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

示例 1：

>输入：`s = "aab"`
>输出：`[["a","a","b"],["aa","b"]]`

示例 2：

>输入：`s = "a"`
>输出：`[["a"]]`

**提示：**

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成

# 解题思路与实现

这道题是 **典型回溯 + DFS + 剪枝** 问题：
1. **从左到右枚举切割点**
    - 用一个 `for` 循环尝试从当前起点 `start` 切出不同长度的子串。
2. **判断当前切出的子串是否是回文**
    - 如果是回文，加入当前路径 `path`，继续递归处理剩余字符串。
    - 如果不是回文，直接剪枝，不再递归。
3. **递归 + 回溯**
    - 递归处理剩余部分（`dfs(i+1)`）
    - 回溯时弹出最后一段（`path.pop()`），尝试其他切法
4. **结束条件**
    - 当 `start == len(s)`，说明已经切完字符串，保存当前 `path` 为一个完整方案。

| **维度**    | **分析内容**                                                                                                                                                                                 |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **回溯法 + 双指针逻辑**。<br>1. **切割点选择**：循环中的 `i` 代表当前的切割位置。从 `start` 到 `i` 形成一个子串。<br>2. **有效性剪枝**：调用 `isP` 函数。只有当前切下的子串是回文时，才继续向后递归。<br>3. **终止条件**：当 `start` 指针到达字符串末尾，说明整个字符串被成功分割成了若干个回文子串。 |
| **空间复杂度** | $O(N)$<br>主要开销是递归调用栈的深度，最大深度为 $N$（即每个字符都被切开的情况）。                                                                                                                                         |
| **时间复杂度** | $O(N \cdot 2^N)$<br>在最坏情况下（如字符串全是相同字符），每个位置都可以切或不切，共有 $2^{N-1}$ 种切割方式，每种方式都需要 $O(N)$ 校验回文。                                                                                               |
| **优点**    | 1. **结构严谨**：完美体现了“枚举切割点 -> 校验 -> 递归剩余部分”的逻辑流。<br>2. **逻辑复用**：将回文判断独立为函数，使主递归逻辑清晰易读。                                                                                                      |

## 方法一：

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        path = []

        def isP(l,r):
            while l < r:
                if s[l] != s[r]:
                    return False
                l += 1
                r -= 1
            return True
        def dfs(start):
            if start == len(s):
                res.append(path[:])
                return
            for i in range(start, len(s)):
                if isP(start,i):
                    path.append(s[start:i+1])
                    dfs(i+1)
                    path.pop()
        dfs(0)
        return res
```