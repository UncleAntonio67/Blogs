🏷中等 #字符串 #动态规划 #回溯 

给你一个字符串 `s`，请你将 `s` 分割成一些 子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

示例 1：

输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
示例 2：

输入：s = "a"
输出：[["a"]]

**提示：**

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成

# 解题思路与实现

这道题是 **典型回溯 + DFS + 剪枝** 问题：
1. **从左到右枚举切割点**
    - 用一个 `for` 循环尝试从当前起点 `start` 切出不同长度的子串。
2. **判断当前切出的子串是否是回文**
    - 如果是回文，加入当前路径 `path`，继续递归处理剩余字符串。
    - 如果不是回文，直接剪枝，不再递归。
3. **递归 + 回溯**
    - 递归处理剩余部分（`dfs(i+1)`）
    - 回溯时弹出最后一段（`path.pop()`），尝试其他切法
4. **结束条件**
    - 当 `start == len(s)`，说明已经切完字符串，保存当前 `path` 为一个完整方案。

## 方法一：

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        path = []

        def isP(l,r):
            while l < r:
                if s[l] != s[r]:
                    return False
                l += 1
                r -= 1
            return True
        def dfs(start):
            if start == len(s):
                res.append(path[:])
                return
            for i in range(start, len(s)):
                if isP(start,i):
                    path.append(s[start:i+1])
                    dfs(i+1)
                    path.pop()
        dfs(0)
        return res
```