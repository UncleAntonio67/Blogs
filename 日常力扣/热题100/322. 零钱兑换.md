🏷中等 #广度优先搜索 #数组 #动态规划 

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

示例 1：

>输入：`coins = [1, 2, 5], amount = 11`
>输出：`3` 
>解释：`11 = 5 + 5 + 1`

示例 2：

>输入：`coins = [2], amount = 3`
>输出：`-1`

示例 3：

>输入：`coins = [1], amount = 0`
>输出：`0`

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`


# 解题思路与实现

`dp[x] = min(dp[x - coin] + 1)`
本质是：把“最后用哪个硬币”枚举一遍，取最少的那种组合。

| **维度**    | **详细分析**                                                                                                                                                                     |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **动态规划 (完全背包)**。<br>定义 `dp[i]` 为凑成金额 `i` 所需的最少硬币数量。<br>对于每个金额 `x`，我们遍历所有硬币 `coin`，尝试“拿”这枚硬币，那么状态就转移自 `dp[x - coin]`。<br>转移方程：$dp[x] = \min(dp[x], dp[x - \text{coin}] + 1)$。 |
| **代码评价**  | **S (生产级标准)**。<br>1. **初始化**：`dp` 数组初始化为 `float('inf')` 是非常老练的处理方式，避免了用 `-1` 初始化时需要额外的判断逻辑。<br>2. **边界**：`dp[0] = 0` 处理正确。<br>3. **返回值**：最后的 `else -1` 判断精准处理了无法凑成的情况。       |
| **时间复杂度** | **$O(S \cdot n)$**。<br>$S$ 是金额 (`amount`)，$n$ 是面额数 (`len(coins)`)。我们需要计算 $S$ 个状态，每个状态遍历 $n$ 次。                                                                               |
| **空间复杂度** | **$O(S)$**。<br>需要一个长度为 `amount + 1` 的 DP 数组。                                                                                                                                 |

## 方法一：

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        for x in range(1,amount+1):
            for coin in coins:
                if x - coin >= 0:
                    dp[x] = min(dp[x], dp[x-coin]+1)
        return dp[amount] if dp[amount] != float('inf') else -1

```