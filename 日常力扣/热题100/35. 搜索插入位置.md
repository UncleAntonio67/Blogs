🏷简单 #数组 #二分查找 

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

>**输入:** `nums = [1,3,5,6], target = 5`
>**输出:** `2`

**示例 2:**

>**输入:** `nums = [1,3,5,6], target = 2`
>**输出:** `1`

**示例 3:**

>**输入:** `nums = [1,3,5,6], target = 7`
>**输出:** `4`

**提示:**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-104 <= target <= 104`

# 解题思路与实现

- 二分查找

| **维度**    | **分析内容**                                                                                                                                                                              |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **分而治之 (Divide and Conquer)**。<br>1. **查找范围**：初始化左右边界 `left` 和 `right`。<br>2. **收缩空间**：每次取中间值 `mid`，根据大小关系排除掉一半的搜索区间。<br>3. **插入点逻辑**：如果最终没找到，`left` 刚好停留在第一个“大于目标值”的元素位置上，这正是理想的插入点。 |
| **边界条件**  | **闭区间 `[left, right]`**。<br>1. 循环条件用 `while left <= right`。<br>2. 更新边界用 `mid - 1` 或 `mid + 1`。<br>这确保了所有元素都能被覆盖到，不会陷入死循环。                                                             |
| **时间复杂度** | $O(\log N)$<br>每次操作都将搜索范围缩小一半，是处理大规模有序数组最高效的方法。                                                                                                                                       |
| **空间复杂度** | $O(1)$<br>只使用了常数个变量，不依赖递归栈。                                                                                                                                                           |

## 方法一：

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        for i, v in enumerate(nums):
            if v >= target:
                return i
        return len(nums)
```

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left
```