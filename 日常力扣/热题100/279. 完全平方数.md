🏷中等 #广度优先搜索 #数学 #动态规划 

给你一个整数 `n` ，返回 _和为 `n` 的完全平方数的最少数量_ 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

示例 1：

>输入：`n = 12`
>输出：`3 `
>解释：`12 = 4 + 4 + 4`

示例 2：

>输入：`n = 13`
>输出：`2`
>解释：`13 = 4 + 9`


**提示：**

- `1 <= n <= 104`

# 解题思路与实现

状态转移方程
`dp[0] = 0`
`dp[i] = min{j >= 1, j*j <= i} (dp[i - j*j] + 1)`

| **维度**    | **详细分析**                                                                                                                                              |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **动态规划 (背包类)**。<br>我们将整数 $n$ 看作背包容量，将所有平方数 $1, 4, 9, 16...$ 看作物品重量。<br>问题转化为：装满容量为 $n$ 的背包，最少需要多少个物品。<br>转移方程：$dp[i] = \min(dp[i], dp[i - j^2] + 1)$。 |
| **时间复杂度** | **$O(N\sqrt{N})$**。<br>外层循环 $N$ 次。内层循环对于每个 $i$ 遍历 $\sqrt{i}$ 次。总次数约为 $\sum \sqrt{i} \approx N\sqrt{N}$。                                               |
| **空间复杂度** | **$O(N)$**。<br>需要一个长度为 $N+1$ 的数组。                                                                                                                     |

## 方法一：

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [0] + [float('inf')] *n
        for i in range(1, n+1):
            j = 1
            while j*j <= i:
                dp[i] = min(dp[i], dp[i-j*j]+1)
                j += 1
        return dp[n]
```