🏷中等 #数组 #双指针 #排序 
给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

示例 1：

输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
示例 2：

输入：nums = [2,0,1]
输出：[0,1,2]

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

**进阶：**

- 你能想出一个仅使用常数空间的一趟扫描算法吗？

# 解题思路与实现

🔹 核心点
指针含义
p0：下一个 0 放的位置
p2：下一个 2 放的位置
curr：当前扫描位置
交换逻辑
遇到 0 → 交换到左边，p0 和 curr 都加 1
遇到 2 → 交换到右边，p2 减 1（curr 不动，需要检查交换过来的值）
遇到 1 → curr 加 1
结束条件
当 curr > p2，说明所有元素都已经归位
## 方法一：

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        p0,curr = 0,0
        p2 = len(nums)-1

        while curr <= p2:
            if nums[curr] == 0:
                nums[curr],nums[p0] = nums[p0],nums[curr]
                p0 += 1
                curr += 1
            elif nums[curr] == 2:
                nums[curr],nums[p2] = nums[p2],nums[curr]
                p2 -= 1
            else:
                curr += 1
```