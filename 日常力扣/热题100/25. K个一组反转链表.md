🏷困难 #递归 #链表 

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

![ | 400](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

**输入：head = [1,2,3,4,5], k = 2
输出：**[2,1,4,3,5]

**示例 2：**

![ | 400](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

**输入：head = [1,2,3,4,5], k = 3
输出：**[3,2,1,4,5]

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

**进阶：你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？


# 解题思路与实现

- **计算链表长度**：我们首先通过遍历链表计算出链表的长度 `count`，如果链表的长度小于 `k`，直接返回原链表，因为无法进行反转。
- **反转 K 个节点**：如果长度大于等于 `k`，我们开始反转前 `k` 个节点。通过遍历并反转链表的 `next` 指针。
- **递归反转**：反转完前 `k` 个节点后，我们通过递归调用 `reverseKGroup` 来处理剩余部分的链表。

## 方法一：递归

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        count = 0
        current = head
        while current:
            count += 1
            current = current.next
        if count < k:
            return head
        prev, curr = None, head
        for _ in range(k):
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        head.next = self.reverseKGroup(curr,k)
        return prev
	
```