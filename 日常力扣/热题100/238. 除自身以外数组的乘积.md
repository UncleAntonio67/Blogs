🏷中等 #数组 #前缀和 

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

**输入:** nums = `[1,2,3,4]`
**输出:** `[24,12,8,6]`

**示例 2:**

**输入:** nums = [-1,1,0,-3,3]
**输出:** [0,0,9,0,0]

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- 输入 **保证** 数组 `answer[i]` 在  **32 位** 整数范围内

**进阶：你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为** 额外空间。）

# 解题思路与实现

- 除法最简单，但是要处理存在0的情况
- 如果知道了 i 左边所有数的乘积，以及 i 右边所有数的乘积，就可以算出 answer[i]。

## 方法一：除法

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        result = [0] * len(nums)
        pro = 1
        tmp = 1
        count = 0
        for i in range(len(nums)):
            pro = pro * nums[i]
        if pro != 0:
            for i in range(len(nums)):
                result[i] = int(pro / nums[i])
        else:
            for i in range(len(nums)):
                if(nums[i] != 0):
                    tmp = tmp * nums[i]
                else:
                    pos = i
                    count += 1
            if(count == 1):
                result[pos] = tmp
        return result
```

## 方法二：前缀后缀

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        pre = [1] * n
        suf = [1] * n
        for i in range(1,n):
            pre[i] = pre[i-1] * nums[i-1]
        for i in range(n-2,-1,-1):
            suf[i] = suf[i+1] * nums[i+1]
        return [p*s for p, s in zip(pre, suf)]
```