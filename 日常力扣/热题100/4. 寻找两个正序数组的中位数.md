🏷困难 #数组 #二分查找 #分治 

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

示例 1：

>输入：`nums1 = [1,3], nums2 = [2]`
>输出：`2.00000`
>解释：`合并数组 = [1,2,3] ，中位数 2`

示例 2：

>输入：`nums1 = [1,2], nums2 = [3,4]`
>输出：`2.50000`
>解释：`合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5`


**提示：**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-106 <= nums1[i], nums2[i] <= 106`


# 解题思路与实现

- 用两个指针 `i`、`j` 指向两个数组开头
- 一共向前取 `mid + 1` 个元素
- 每次都从两个数组当前未使用的最小值中取一个
- 用 `prev` 和 `curr` 记录当前和上一个被取出的元素
- 根据总长度奇偶返回：
    - 奇数：返回 `curr`
    - 偶数：返回`(prev + curr)/2`

| **维度**    | **分析内容**                                                                                                                                                                                                  |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **双指针归并模拟**。<br>1. **逻辑合并**：不需要真的创建一个长度为 $m+n$ 的新数组，而是利用两个指针 `i` 和 `j` 模拟合并过程。<br>2. **中位数定位**：通过循环执行 `(m+n)//2 + 1` 次，找到中位数所在的位置。<br>3. **状态保留**：由于偶数长度需要两个中间数的平均值，所以用 `prev` 和 `curr` 分别保存上一个和当前移动到的数值。 |
| **关键判断**  | `if i < m and (j >= n or nums1[i] <= nums2[j])`：这个判断条件处理得非常漂亮，优雅地解决了其中一个数组先遍历完（越界）的情况。                                                                                                                    |
| **时间复杂度** | $O(m + n)$<br>你需要遍历到两个数组总长度的一半位置。                                                                                                                                                                         |
| **空间复杂度** | $O(1)$<br>只使用了常数个变量，比起真正合并数组的 $O(m+n)$ 空间复杂度有显著优势。                                                                                                                                                        |
## 方法一：

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m,n = len(nums1), len(nums2)
        total = m + n
        mid = total // 2
        i = j = 0
        prev = curr = 0
        for _ in range(mid + 1):
            prev = curr
            if i < m and(j >= n or nums1[i] <= nums2[j]):
                curr = nums1[i]
                i += 1
            else:
                curr = nums2[j]
                j += 1
        if total % 2 == 1:
            return curr
        return (prev + curr) / 2
```