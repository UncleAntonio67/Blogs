🏷简单 #数组 #动态规划 

给定一个非负整数 `numRows`，生成「杨辉三角」的前 _`numRows`_ 行。

在「杨辉三角」**中，每个数是它左上方和右上方的数的和。

![|200](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

**示例 1:**

**输入:** `numRows = 5`
**输出:** `[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]`

**示例 2:**

**输入:** `numRows = 1`
**输出:** `[[1]]`

**提示:**

- `1 <= numRows <= 30`

# 解题思路与实现

总结规律

| **维度**    | **详细分析**                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **核心思路**  | **动态规划 (DP) / 数学模拟**。<br>利用杨辉三角的数学性质：`Current[i][j] = Previous[i-1][j-1] + Previous[i-1][j]`。<br>通过每一行的首尾固定为 1，中间元素由上一行推导而来。                                                                           |
| **代码关键点** | 1. **巧用初始化**：`row = [1]*(i+1)`。这一步非常聪明，直接把首尾的 1 填好了，循环只需要处理中间部分 `range(1, i)`。<br>2. **状态转移**：`row[j] = res[i-1][j-1] + res[i-1][j]`。<br>3. **Bug 修正**：必须 `return res` (整个列表)，而不是 `return row` (最后一行)。 |
| **时间复杂度** | **$O(N^2)$**<br>第 1 行计算 1 个数，第 2 行计算 2 个数... 第 $N$ 行计算 $N$ 个数。<br>总运算次数为等差数列求和：$1 + 2 + \dots + N \approx \frac{N^2}{2}$。                                                                              |
| **空间复杂度** | **$O(N^2)$**<br>我们需要存储所有的数字来返回结果。如果只计算不存储（或只求某一行），空间可以优化到 $O(N)$，但本题要求返回整个三角形。                                                                                                                         |


## 方法一：

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for i in range(numRows):
            row = [1] * (i+1)
            for j in range(1,i):
                row[j] = res[i-1][j-1] + res[i-1][j]
            res.append(row)
        return res
```