ğŸ·ç®€å• #æ ‘ #æ·±åº¦ä¼˜å…ˆæœç´¢ #å¹¿åº¦ä¼˜å…ˆæœç´¢ #äºŒå‰æ ‘

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â `root`Â ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

**ç¤ºä¾‹ 1ï¼š**

![ | 250](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3]
è¾“å‡ºï¼štrue
**ç¤ºä¾‹ 2ï¼š**

![250](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3]
è¾“å‡ºï¼šfalse

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´Â `[1, 1000]`Â å†…
- `-100 <= Node.val <= 100`

**è¿›é˜¶ï¼šä½ å¯ä»¥è¿ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿ

# è§£é¢˜æ€è·¯ä¸å®ç°

- é€’å½’

## æ–¹æ³•ä¸€ï¼šé€’å½’

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        def isMirror(t1,t2):
            if not t1 and not t2:
                return True
            if not t1 or not t2:
                return False
            return (t1.val == t2.val and
            isMirror(t1.left,t2.right) and
            isMirror(t1.right,t2.left))
        return isMirror(root.left, root.right)
```