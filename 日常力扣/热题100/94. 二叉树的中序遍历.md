ğŸ·ç®€å• #äºŒå‰æ ‘ #æ ˆ #æ·±åº¦ä¼˜å…ˆæœç´¢

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â `root`Â ï¼Œè¿”å›Â _å®ƒçš„Â **ä¸­åº**Â éå†_Â ã€‚

**ç¤ºä¾‹ 1ï¼š**

![ | 100](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

>è¾“å…¥ï¼š`root = [1,null,2,3]`
>è¾“å‡ºï¼š`[1,3,2]`

ç¤ºä¾‹ 2ï¼š

>è¾“å…¥ï¼š`root = []`
>è¾“å‡ºï¼š`[]`

ç¤ºä¾‹ 3ï¼š

>è¾“å…¥ï¼š`root = [1]`
>è¾“å‡ºï¼š`[1]`

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´Â `[0, 100]`Â å†…
- `-100 <= Node.val <= 100`

**è¿›é˜¶:**Â é€’å½’ç®—æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥é€šè¿‡è¿­ä»£ç®—æ³•å®Œæˆå—ï¼Ÿ

# è§£é¢˜æ€è·¯ä¸å®ç°

- é€’å½’
- è¿­ä»£

|**ç»´åº¦**|**æ–¹æ³•ä¸€ï¼šé€’å½’ (Recursive)**|**æ–¹æ³•äºŒï¼šè¿­ä»£ (Iterative)**|
|---|---|---|
|**åº•å±‚åŸç†**|åˆ©ç”¨**ç³»ç»Ÿéšå¼è°ƒç”¨æ ˆ**ã€‚å‡½æ•°ä¸æ–­è‡ªæˆ‘è°ƒç”¨ï¼Œç›´åˆ°è§¦åŠ `None` åé€å±‚è¿”å›ã€‚|åˆ©ç”¨**è‡ªå®šä¹‰æ˜¾å¼æ ˆ (`list`)**ã€‚é€šè¿‡é€»è¾‘æ§åˆ¶èŠ‚ç‚¹è¿›æ ˆå’Œå‡ºæ ˆçš„æ—¶æœºã€‚|
|**ä»£ç ç®€æ´åº¦**|**æç®€**ã€‚é€»è¾‘é«˜åº¦æŠ½è±¡ï¼Œä»…éœ€å‡ è¡Œä»£ç å³å¯è¡¨è¾¾â€œå·¦-æ ¹-å³â€çš„å«ä¹‰ã€‚|**è¾ƒå¤æ‚**ã€‚éœ€è¦æ‰‹åŠ¨å¤„ç†æŒ‡é’ˆåˆ‡æ¢ï¼ˆ`cur = cur.left/right`ï¼‰å’Œå¾ªç¯æ¡ä»¶ã€‚|
|**ç©ºé—´å¤æ‚åº¦**|**å¹³å‡ $O(h)$**ï¼Œæœ€å·® $O(n)$ã€‚å—ç³»ç»Ÿæ ˆæ·±åº¦é™åˆ¶ã€‚|**å¹³å‡ $O(h)$**ï¼Œæœ€å·® $O(n)$ã€‚å—å†…å­˜ä¸­å®šä¹‰çš„æ ˆç©ºé—´é™åˆ¶ã€‚|
|**æ ˆæº¢å‡ºé£é™©**|**æœ‰é£é™©**ã€‚åœ¨å¤„ç†ææ·±çš„æ ‘ï¼ˆå¦‚é€€åŒ–æˆé“¾è¡¨çš„æ ‘ï¼‰æ—¶ï¼Œå¯èƒ½è§¦å‘ `RecursionError`ã€‚|**æ— é£é™©**ã€‚æ˜¾å¼æ ˆå­˜å‚¨åœ¨å †å†…å­˜ä¸­ï¼Œå®¹é‡è¿œå¤§äºç³»ç»Ÿè°ƒç”¨æ ˆã€‚|
|**è°ƒè¯•éš¾åº¦**|è¾ƒéš¾ã€‚åœ¨æ·±å±‚é€’å½’ä¸­è·Ÿè¸ªå˜é‡çŠ¶æ€æ¯”è¾ƒç›´è§‚ï¼Œä½†è·³è½¬é€»è¾‘å¤æ‚ã€‚|è¾ƒæ˜“ã€‚å¯ä»¥é€šè¿‡æ‰“å°æ ˆçš„çŠ¶æ€ï¼ˆ`print(stack)`ï¼‰æ¸…æ™°çœ‹åˆ°æ¯ä¸€æ­¥çš„å˜åŒ–ã€‚|
|**æ‰§è¡Œæ•ˆç‡**|ç•¥ä½ã€‚é¢‘ç¹çš„å‡½æ•°å‹æ ˆå’Œå‡ºæ ˆä¼šæœ‰ä¸€å®šçš„é¢å¤–å¼€é”€ã€‚|ç•¥é«˜ã€‚ä»…æ¶‰åŠç®€å•çš„å¾ªç¯å’Œåˆ—è¡¨æ“ä½œã€‚|
## æ–¹æ³•ä¸€ï¼šé€’å½’

```python 
class Solution:
Â  Â  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
Â  Â  Â  Â  res = []
Â  Â  Â  Â  def dfs(node):
Â  Â  Â  Â  Â  Â  if not node:
Â  Â  Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  Â  Â  dfs(node.left)
Â  Â  Â  Â  Â  Â  res.append(node.val)
Â  Â  Â  Â  Â  Â  dfs(node.right)
Â  Â  Â  Â  dfs(root)
Â  Â  Â  Â  return res
```

## æ–¹æ³•äºŒï¼šè¿­ä»£

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res, stack =[],[]
        cur = root
        while cur or stack:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack.pop()
            res.append(cur.val)
            cur = cur.right
        return res
```