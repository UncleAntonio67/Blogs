ğŸ·ç®€å• #äºŒå‰æ ‘ #æ ˆ #æ·±åº¦ä¼˜å…ˆæœç´¢

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â `root`Â ï¼Œè¿”å›Â _å®ƒçš„Â **ä¸­åº**Â éå†_Â ã€‚

**ç¤ºä¾‹ 1ï¼š**

![ | 100](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

è¾“å…¥ï¼šroot = [1,null,2,3]
è¾“å‡ºï¼š[1,3,2]
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´Â `[0, 100]`Â å†…
- `-100 <= Node.val <= 100`

**è¿›é˜¶:**Â é€’å½’ç®—æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥é€šè¿‡è¿­ä»£ç®—æ³•å®Œæˆå—ï¼Ÿ

# è§£é¢˜æ€è·¯ä¸å®ç°

- é€’å½’
- è¿­ä»£

## æ–¹æ³•ä¸€ï¼šé€’å½’

```python 
class Solution:
Â  Â  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
Â  Â  Â  Â  res = []
Â  Â  Â  Â  def dfs(node):
Â  Â  Â  Â  Â  Â  if not node:
Â  Â  Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  Â  Â  dfs(node.left)
Â  Â  Â  Â  Â  Â  res.append(node.val)
Â  Â  Â  Â  Â  Â  dfs(node.right)
Â  Â  Â  Â  dfs(root)
Â  Â  Â  Â  return res
```

## æ–¹æ³•äºŒï¼šè¿­ä»£

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res, stack =[],[]
        cur = root
        while cur or stack:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack.pop()
            res.append(cur.val)
            cur = cur.right
        return res
```