
# 🔑 哈希表

哈希表（字典/集合）是算法面试和编程中**最重要的工具之一**，能将许多问题的复杂度从 $O(n^2)$ 优化到 $O(n)$。
## 常见套路
### 1. 查找配对与补数 (Two-Sum Pattern)

这是哈希表最经典且最常用的套路，用于将二次时间复杂度优化为线性时间复杂度。

- **目标：** 在数组中找到满足 $x + y = Target$ 或 $x - y = Target$ 的两个数 $x, y$。
- **核心解法：** **单次遍历 + 查找补数**。遍历数组时，计算所需的 **补数（Complement）**，并立即在哈希表中查找它是否已存在。
- **哈希表作用：** 存储已遍历元素的**值**和对应的**索引**。

| **典型问题**             | **LeetCode 题目**               | **复杂度优化**                |
| -------------------- | ----------------------------- | ------------------------ |
| **两数之和**             | LC 1. Two Sum                 | $O(n^2) \to O(n)$        |
| **三数之和 (Three Sum)** | LC 15. 3Sum                   | 转换为排序 + $O(n)$ 双指针       |
| **子数组和等于 K**         | LC 560. Subarray Sum Equals K | $O(n^2) \to O(n)$（利用前缀和） |

### 2.频率统计与分组 (Counting & Grouping)

利用哈希字典进行元素的计数和分类。

- **目标：** 统计元素出现频率，或根据某种**规范化形式**对数据进行分组。
- **核心解法：** 使用 `defaultdict(int)` 或 `dict` 存储 `元素 : 频率`，或存储 `规范化键 : 原始元素列表`。
- **哈希表作用：** **计数** 和 **建立多值映射**。

|**典型问题**|**LeetCode 题目**|**哈希键的生成方式**|
|---|---|---|
|**多数元素**|LC 169. Majority Element|元素本身作为键，计数作为值。|
|**Top K 频繁元素**|**LC 347. Top K Frequent Elements**|元素本身作为键，频率作为值（常结合堆）。|
|**字母异位词分组**|**LC 49. Group Anagrams**|**排序后的字符串** 或 **字符计数元组** 作为键。|

### 3.去重与查找连续性 (Deduplication & Consecutiveness)

利用哈希集合 (`set`) 快速判断元素的**存在性**。

- **目标：** 快速判断某个元素是否存在，或查找不重复元素构成的序列。
- **核心解法：** 将所有元素预先存入哈希集合，然后利用 $O(1)$ 查找来简化判断。
- **哈希集合作用：** **去重** 和 **$O(1)$ 查找**。

| **典型问题**       | **LeetCode 题目**                                          | **优化思路**                                   |
| -------------- | -------------------------------------------------------- | ------------------------------------------ |
| **最长连续序列**     | **LC 128. Longest Consecutive Sequence**                 | $O(n \log n)$ 排序 $\to O(n)$ 哈希集查找**序列起点**。 |
| **无重复字符的最长子串** | **LC 3. Longest Substring Without Repeating Characters** | 结合**滑动窗口**，用集合快速判断字符是否重复。                  |
## 通用步骤

### 步骤 1: 确定哈希表的类型和内容

- **需要计数或映射吗？** $\to$ 使用 **字典** (`dict`)。内容为 `{值 : 频率/索引}`。
- **只需要判断存在性或去重吗？** $\to$ 使用 **集合** (`set`)。内容为 `{值}`。
### 步骤 2: 规范化键 (如果需要分组)

如果目标是将相似对象分组（如异位词），你需要将它们转化为一个**唯一且可哈希**的键。

- **字符串：** 排序后的字符串或字符计数元组。
- **坐标/复杂对象：** 元组 `tuple`（因为列表 `list` 不可哈希）。
### 步骤 3: 实施单次遍历优化

对于查找配对（如 Two Sum），始终尝试使用单次遍历：

1. 遍历当前元素 $x$。
2. 计算目标数 $Target - x$。
3. **查找：** 检查 $Target - x$ 是否在哈希表中。
    - **如果在：** 成功找到，返回结果。
    - **如果不在：** 将当前元素 $x$ 及其信息（如索引）存入哈希表，供后续元素查找。
### 步骤 4: 巧用 Python 辅助工具

使用 `collections` 模块可以极大地简化代码。

| **工具**              | **作用**                    | **示例**                 |
| ------------------- | ------------------------- | ---------------------- |
| `defaultdict(int)`  | 自动将不存在的键初始化为 `0` (用于计数)。  | `d[key] += 1`          |
| `defaultdict(list)` | 自动将不存在的键初始化为 `[]` (用于分组)。 | `d[key].append(value)` |
| `set()`             | 用于 $O(1)$ 快速去重和查找。        | `if num in my_set:`    |

# 🔑 双指针

## 常见套路

### 1.相向/对撞双指针 (Opposite/Converging Pointers)

两个指针从数据结构的两端**相向移动**，通常用于**已排序**的数组中。

| **套路**         | **描述**                   | **典型问题**                                       |
| -------------- | ------------------------ | ---------------------------------------------- |
| **Two Sum 变种** | 查找满足特定条件的一对或多对元素。        | **LC 167. Two Sum II** (排序数组)、**LC 15. 3Sum**。 |
| **贪心收敛**       | 基于某一条件（如最短板）进行取舍，指导指针移动。 | **LC 11. Container With Most Water** (盛水容器)。   |
| **中心对称**       | 用于检查字符串或数组是否具有对称性。       | **LC 125. Valid Palindrome** (验证回文串)。          |

### B. 同向双指针/快慢指针 (Same-Direction/Fast-Slow Pointers) 🚶‍♂️💨

两个指针从数据的同一起点或不同位置**同向移动**，通常用于原地修改数组或处理链表结构。

| **套路**      | **描述**                  | **典型问题**                                                               |
| ----------- | ----------------------- | ---------------------------------------------------------------------- |
| **原地修改/重排** | 慢指针记录有效数据的写入位置，快指针遍历数据。 | **LC 283. Move Zeroes** (移动零)、**LC 26. Remove Duplicates**。            |
| **滑动窗口**    | 两个指针定义窗口边界，用于查找子数组/子串。  | **LC 3. Longest Substring Without Repeating Characters** (无重复字符的最长子串)。 |
| **链表结构**    | 指针以不同速度移动，用于判断循环或查找中点。  | **LC 141. Linked List Cycle** (环形链表)。                                  |
## 通用步骤

### 步骤 1: 预处理和初始化

- **排序 (如果需要)：** 如果问题涉及查找配对且数组未排序（如 3Sum），必须先排序 ($O(n \log n)$)。
- **指针初始化：**
    - **相向：** `left = 0`, `right = len(arr) - 1`。
    - **同向：** `slow = 0`, `fast = 0` 或 `fast = 1`。

### 步骤 2: 确定循环和移动策略 🎯

这是算法的核心，$O(n)$ 效率的关键所在。

|**套路**|**循环条件**|**移动策略 (核心)**|
|---|---|---|
|**相向**|`while left < right`|根据 **和 (Sum)** 或 **面积 (Area)** 与目标值的大小关系，移动左指针 (`left++`) 或右指针 (`right--`)。|
|**同向**|`while fast < len(arr)`|**根据 `fast` 指向的值** 是否满足条件来操作：若满足，则用 `fast` 的值覆盖 `slow` 的位置，并 `slow++`。无论如何，`fast++`。|
### 步骤 3: 处理去重和边界

- **去重：** 在找到解后（如 3Sum），或在移动指针后，必须跳过与前一个元素重复的元素，以确保结果不重复。
- **边界：** 确保在移动指针前，检查它们是否在有效范围内。