🏷中等 #贪心 #数组 #动态规划 

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

示例 1：

>输入：`nums = [2,3,1,1,4]`
>输出：`true`
>解释：`可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。`

示例 2：

>输入：`nums = [3,2,1,0,4]`
>输出：`false`
>解释：`无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。`

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`

# 解题思路与实现

- **如果 i > max_i：**  
    → 说明这个地方根本跳不到  
    → 直接 return False
- 否则：  
    → 更新最远可达位置：


| **维度**    | **分析内容**                                                                                                                                                                   |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **动态维护覆盖范围 (Reachable Range)**。<br>1. **遍历索引**：遍历每一个位置 `i`。<br>2. **可达性检查**：如果当前索引 `i` 已经超过了目前能到达的最远位置 `max_i`，说明发生了断层，无法继续前进。<br>3. **范围更新**：在每个可达的点，尝试更新最远射程 `i + step`。 |
| **贪心性质**  | 只要我们能到达位置 `i`，那么 `i` 之前的所有位置一定也是可达的。我们只关心当前能跳到的极限。                                                                                                                         |
| **时间复杂度** | $O(N)$<br>只需线性扫描一遍数组。                                                                                                                                                      |
| **空间复杂度** | $O(1)$<br>只使用了一个变量 `max_i`。                                                                                                                                                |

## 方法一：

```python
class Solution:
    def canJump(self, nums: list[int]) -> bool:
        max_i = 0
        for i, step in enumerate(nums):
            if i > max_i:
                return False  # 无法前进，被卡住
            max_i = max(max_i, i + step)
        return True
```