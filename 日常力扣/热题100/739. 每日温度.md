🏷中等 #栈 #数组 #单调栈

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

>**输入:** ``temperatures` = [73,74,75,71,69,72,76,73]`
>**输出:** `[1,1,4,2,1,1,0,0]`

**示例 2:**

>**输入:** `temperatures = [30,40,50,60]`
>**输出:** `[1,1,1,0]`

**示例 3:**

>**输入:** `temperatures = [30,60,90]`
>**输出:** `[1,1,0]`

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

# 解题思路与实现

用 **单调递减栈（存索引）**，栈中保存 **还没找到更高温度的日子**。遍历温度数组，每遇到比栈顶温度高的新温度，就不断弹出栈顶索引并计算等待天数。

| **维度**    | **分析内容**                                                                                                                                                            |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心思路**  | **维护一个单调递减栈**。<br>1. **栈内存放索引**：存储下标而不是数值，方便计算天数差 `i - idx`。<br>2. **触发更新**：当今天温度比栈顶索引对应的温度高时，说明栈顶那些天终于等到了“更暖和的一天”。<br>3. **结算与弹出**：弹出栈顶并记录间隔，继续检查新的栈顶，直到栈为空或遇到更高温。 |
| **单调性**   | 栈底到栈顶的温度是**从高到低**排列的。这种结构保证了我们总是在和“最近的一个待解决日期”做比较。                                                                                                                  |
| **时间复杂度** | $O(n)$<br>虽然有嵌套循环，但每个索引最多进栈一次、出栈一次。                                                                                                                                 |
| **空间复杂度** | $O(n)$<br>最坏情况下（温度持续下降），栈会存储所有下标。                                                                                                                                   |
## 方法一：

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        ans = [0]*n
        stack = []

        for i in range(n):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                idx = stack.pop()
                ans[idx] = i - idx
            stack.append(i)

        return ans
```
