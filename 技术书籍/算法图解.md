作者： Martin Kleppmann                        
阅读日期：20250811——20250830
学习网站：http://ddia.vonng.com/

# 第1章 算法简介

查字典的例子给出二分查找算法：
```python
def binarySearch(list,item):
	low = 0
	high = len(list)-1
	while low < high:
		mid = low + high / 2
		guess = list[mid]
		if guess == item:
			return mid
		if guess > item:
			high = mid - 1
		else:
			low = mid + 1
	return None
	
my_list=[1,2,5,6,8]
print binarySearch(my_list, 5)
```

大O表示法：

![[file-20251029205156987.jpg]]

旅行商问题——运行时间O(n!)的算法

涉及n个城市时，需要执行n !（n的阶乘）次操作才能计算出结果。因此运行时间为O(n!)，即阶乘时间。除非涉及的城市数很少。

**小节：**
- 二分查找的速度比简单查找快得多。O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
- 算法运行时间并不以秒为单位。
- 算法运行时间是从其增速的角度度量的。
- 算法运行时间用大O表示法表示。

# 第2章 选择排序

通过看电影选座引入数组、链表
通过歌单排序引入选择排序，时间复杂度O(n2)：

```python
def findSmallest(arr):
  smallest = arr[0]  ←------存储最小的值
  smallest_index = 0  ←------存储最小元素的索引
  for i in range(1, len(arr)):
    if arr[i] < smallest:
      smallest = arr[i]
      smallest_index = i
  return smallest_index
```

```python
def selectionSort(arr):  ←------对数组进行排序
  newArr = []
  for i in range(len(arr)):
      smallest = findSmallest(arr)  ←------找出数组中最小的元素，并将其加入到新数组中
      newArr.append(arr.pop(smallest))
  return newArr

print selectionSort([5, 3, 6, 2, 10])
```
# 第3章 选择排序

外祖母的钥匙问题，引入循环和递归的对比：
- 循环：
```python
def look_for_key(main_box):
  pile = main_box.make_a_pile_to_look_through()
  while pile is not empty:
    box = pile.grab_a_box()
    for item in box:
      if item.is_a_box():
        pile.append(item)
      elif item.is_a_key():
        print "found the key!"
```
- 递归
```python
def look_for_key(box):
  for item in box:
    if item.is_a_box():
      look_for_key(item)  ←------递归！
    elif item.is_a_key():
      print "found the key!"
```
“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”

**每个递归函数都有两部分：基线条件** （base case）**和递归条件** （recursive case）
- 递归条件：函数调用自己
- 基线条件：函数不再调用自己

**调用栈**：用于存储多个函数的变量

使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择。
- 重新编写代码，转而使用循环。
- 使用**尾递归** 。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言都支持尾递归。

# 第4章 快速排序

分而治之：divide and conquer

划分土地的问题，将一块地均匀地分成方块，并确保分出的方块是最大。
**适用于这小块地的最大方块，也是适用于整块地的最大方块**（欧几里得算法）
D&C的工作原理：
- 找出基线条件（什么时候停止）
- 确定如何缩小问题的规模，使其符合基线条件

既然使用循环可轻松地完成任务，为何还要使用递归方式呢？看看函数式编程你就明白了！诸如Haskell等函数式编程语言没有循环，因此你只能使用递归来编写这样的函数。

**快速排序原理：**
- 选基准值
- 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
- 对这两个子数组进行快速排序。

归纳证明法：分两步：基线条件和归纳条件

快速排序的代码：
```python
def quicksort(array):
  if len(array) < 2:
    return array  ←------基线条件：为空或只包含一个元素的数组是“有序”的
  else:
    pivot = array[0]  ←------递归条件
    less = [i for i in array[1:] if i <= pivot]  ←------由所有小于基准值的元素组成的子数组

    greater = [i for i in array[1:] if i > pivot]  ←------由所有大于基准值的元素组成的子数组

    return quicksort(less) + [pivot] + quicksort(greater)

print quicksort([10, 5, 2, 3])
```

快速排序的独特之处在于，其速度取决于选择的基准值。
- 在平均情况下，快速排序的运行时间为_O_ (_n_ log _n_ )，每次都分成了一份
- ![[file-20251110185035066.jpg | 300]]
- 在最糟情况下，其运行时间为_O_ (_n_ 2 )，每次都分成了两份
![[file-20251110185052820.jpg | 350]]
有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。

# 第5章 散列表

杂货店商品价格表的例子引出散列函数，时间复杂度为O（1）

散列函数能够精准找到的关键原因：
- 将同样的输入映射到相同的索引
- 不同的输入映射到不同的索引
- 散列函数知道数组有多大，只返回有效的索引

Python提供的散列表实现为字典，你可使用**函数dict**来创建散列表。

散列表的场景：电话簿、DNS转换、防重、缓存

冲突：给两个键分配的位置相同。

- **散列函数很重要**：前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。

散列表平均操作运行时间O(1)、最糟糕O(n)

填装因子=散列表包含的元素数/位置总数

填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。

# 第6章 广度优先搜索

通过金门大桥的例子引入最短路径问题，解决最短路径问题的算法被称为**广度优先搜索** 。

图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为**邻居**。

广度优先搜索解决两类问题：
- 有没有路径
- 哪条路径最短
一度关系优先于二度关系，需要按添加顺序进行检查。有一个可实现这种目的的数据结构，那就是**队列** （queue）。

队列是一种**先进先出** （First In First Out，FIFO）的数据结构，而栈是一种**后进先出** （Last In First Out，LIFO）的数据结构。

散列表可以表示映射关系。
![[file-20251117221550663.jpg | 400]]
```python 
graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []
```

![[file-20251117222221046.jpg | 450]]
可以出队可以入队，在Python中，可使用函数deque来创建一个双端队列。
```python
from collections import deque
search_queue = deque()  ←------------创建一个队列
search_queue += graph["you"]  ←------将你的邻居都加入到这个搜索队列中

while search_queue:  ←------只要队列不为空
    person = search_queue.popleft()  ←------就取出其中的第一个人
    if person_is_seller(person):  ←------检查这个人是否是芒果销售商
        print person + " is a mango seller!"  ←------是芒果销售商
        return True
    else:
        search_queue += graph[person]  ←------不是芒果销售商。将这个人的朋友都加入搜索队列
return False  ←------如果到达了这里，就说明队列中没人是芒果销售商

def person_is_seller(name):
    return name[-1] == 'm'

```

如果有环，将形成无限循环，所以需要使用一个列表来记录检查过的人
```python
def search(name):
    search_queue = deque()
    search_queue += graph[name]
    searched = []  ←------------------------------这个数组用于记录检查过的人
    while search_queue:
        person = search_queue.popleft()
        if person not in searched:     ←----------仅当这个人没检查过时才检查
            if person_is_seller(person):
                print person + " is a mango seller!"
                return True
            else:
                search_queue += graph[person]
                searched.append(person)    ←------将这个人标记为检查过
    return False


search("you")
```

广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V+ E)，其中V为顶点（vertice）数，E为边数。

# 第7章 狄克斯特拉算法

加权图，狄克斯特拉算法可以帮忙找到最短路径，环会导致该算法不可用

![[file-20251118232349574.jpg | 500]]

(1) 找出最便宜的节点，即可在最短时间内前往的节点。
(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。
(3) 重复这个过程，直到对图中的每个节点都这样做了。
(4) 计算最终路径。（下一节再介绍！）

加权图、非加权图，要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法 。

狄克斯特拉算法只适用于**有向无环图**（directed acyclic graph，DAG）。

通过乐谱换吉他的例子，执行该算法：
狄克斯特拉算法背后的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径！
如果有负权边，就不能使用狄克斯特拉算法

不能将狄克斯特拉算法用于包含负权边的图。在包含负权边的图中，要找出最短路径，可使用另一种算法——**贝尔曼-福德算法**（Bellman-Ford algorithm）。

代码实现：
![[file-20251118234056778.jpg | 500]]
```python
node = find_lowest_cost_node(costs)  ←------在未处理的节点中找出开销最小的节点
while node is not None:  ←------这个while循环在所有节点都被处理过后结束
    cost = costs[node]
    neighbors = graph[node]
    for n in neighbors.keys():  ←------遍历当前节点的所有邻居
        new_cost = cost + neighbors[n]
        if costs[n] > new_cost:  ←------如果经当前节点前往该邻居更近，
            costs[n] = new_cost  ←------就更新该邻居的开销
            parents[n] = node  ←------同时将该邻居的父节点设置为当前节点
            processed.append(node)  ←------将当前节点标记为处理过
    node = find_lowest_cost_node(costs)  ←------找出接下来要处理的节点，并循环
```

```python
def find_lowest_cost_node(costs):
    lowest_cost = float("inf")
    lowest_cost_node = None
    for node in costs:  ←------遍历所有的节点
        cost = costs[node]
        if cost < lowest_cost and node not in processed:  ←------如果当前节点的开销更低且未处理过，
            lowest_cost = cost  ←------就将其视为开销最低的节点
            lowest_cost_node = node
    return lowest_cost_nod
```


# 第8章 贪婪算法

通过安排课程的例子引出贪心，每次都选结束最早的课

背包问题的启示：在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。

集合覆盖问题举例：

```python
states_needed = set(["mt", "wa", "or", "id", "nv", "ut",
"ca", "az"])  ←------你传入一个数组，它被转换为集合

stations = {}
stations["kone"] = set(["id", "nv", "ut"])
stations["ktwo"] = set(["wa", "id", "mt"])
stations["kthree"] = set(["or", "nv", "ca"])
stations["kfour"] = set(["nv", "ut"])
stations["kfive"] = set(["ca", "az"])

final_stations = set()

best_station = None
states_covered = set()
while states_needed:
  best_station = None
  states_covered = set()
  for station, states in stations.items():
    covered = states_needed & states
    if len(covered) > len(states_covered):
      best_station = station
      states_covered = covered


   states_needed -= states_covered
   final_stations.add(best_station)
    
print final_stations
```

旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。

NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。

NP问题的蛛丝马迹：
- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
- 涉及“所有组合”的问题通常是NP完全问题。
- 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
- 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。
- 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。
- 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。


# 第9章 动态规划

用背包问题引入动态规划

![[file-20251208220744065.jpg | 500]]


![[file-20251208220928287.jpg | 600]]

动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。

最长公共子串：
```python
if word_a[i] == word_b[j]:  ←---------两个字母相同
  cell[i][j] = cell[i-1][j-1] + 1
else:  ←------------------------------两个字母不同
  cell[i][j] = 0
```

![[file-20251213134004170.jpg | 300]]

最长公共子序列：

![[file-20251213134345065.jpg | 500]]

![[file-20251213134540299.jpg | 400]]

```python
if word_a[i] == word_b[j]:      ←--------两个字母相同
  cell[i][j] = cell[i-1][j-1] + 1
else:     ←------------------------------两个字母不同
  cell[i][j] = max(cell[i-1][j], cell[i][j-1])
```

**动态规划实际应用**：
- 生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。
- 你使用过诸如git diff等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。
- 编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。
- 

# 第 10 章　K最近邻算法

橙子柚子的例子引出来KNN（k-nearest neighbours，KNN）算法：

![[file-20251213134911814.jpg | 600]]

使用KNN来做两项基本工作——分类和回归：
- 分类就是编组；
- 回归就是预测结果（如一个数字）。

**余弦相似度**：
余弦相似度不计算两个矢量的距离，而比较它们的角度，因此更适合处理前面所说的情况。本书不讨论余弦相似度，但如果你要使用KNN，就一定要研究研究它！

**OCR**：光学字符识别（optical character recognition）
**创建垃圾邮件过滤器**：垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器

# 第 11 章　接下来如何做

- 二叉树
![[file-20251213140407477.jpg | 400]]

- 反向索引
![[file-20251213141457574.jpg | 200]]

- 布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的。为判断网页以前是否已搜集，可不使用散列表，而使用布隆过滤器。使用散列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。
	- 可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。
	- 不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。

- SHA算法
安全散列算法（secure hash algorithm，SHA）函数
![[file-20251213142229167.jpg | 200]]
![[file-20251213142303856.jpg | 300]]

Diffie-Hellman使用两个密钥：公钥和私钥。顾名思义，公钥就是公开的，可将其发布到网站上，通过电子邮件发送给朋友，或使用其他任何方式来发布。你不必将它藏着掖着。有人要向你发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道私钥，就只有你才能解密消息！

