作者： Martin Kleppmann                        
阅读日期：20250811——20250830
学习网站：http://ddia.vonng.com/

# 第1章 算法简介

查字典的例子给出二分查找算法：
```python
def binarySearch(list,item):
	low = 0
	high = len(list)-1
	while low < high:
		mid = low + high / 2
		guess = list[mid]
		if guess == item:
			return mid
		if guess > item:
			high = mid - 1
		else:
			low = mid + 1
	return None
	
my_list=[1,2,5,6,8]
print binarySearch(my_list, 5)
```

大O表示法：

![[file-20251029205156987.jpg]]

旅行商问题——运行时间O(n!)的算法

涉及n个城市时，需要执行n !（n的阶乘）次操作才能计算出结果。因此运行时间为O(n!)，即阶乘时间。除非涉及的城市数很少。

**小节：**
- 二分查找的速度比简单查找快得多。O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
- 算法运行时间并不以秒为单位。
- 算法运行时间是从其增速的角度度量的。
- 算法运行时间用大O表示法表示。

# 第2章 选择排序

通过看电影选座引入数组、链表
通过歌单排序引入选择排序，时间复杂度O(n2)：

```python
def findSmallest(arr):
  smallest = arr[0]  ←------存储最小的值
  smallest_index = 0  ←------存储最小元素的索引
  for i in range(1, len(arr)):
    if arr[i] < smallest:
      smallest = arr[i]
      smallest_index = i
  return smallest_index
```

```python
def selectionSort(arr):  ←------对数组进行排序
  newArr = []
  for i in range(len(arr)):
      smallest = findSmallest(arr)  ←------找出数组中最小的元素，并将其加入到新数组中
      newArr.append(arr.pop(smallest))
  return newArr

print selectionSort([5, 3, 6, 2, 10])
```
# 第3章 选择排序

外祖母的钥匙问题，引入循环和递归的对比：
- 循环：
```python
def look_for_key(main_box):
  pile = main_box.make_a_pile_to_look_through()
  while pile is not empty:
    box = pile.grab_a_box()
    for item in box:
      if item.is_a_box():
        pile.append(item)
      elif item.is_a_key():
        print "found the key!"
```
- 递归
```python
def look_for_key(box):
  for item in box:
    if item.is_a_box():
      look_for_key(item)  ←------递归！
    elif item.is_a_key():
      print "found the key!"
```
“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”

**每个递归函数都有两部分：基线条件** （base case）**和递归条件** （recursive case）
- 递归条件：函数调用自己
- 基线条件：函数不再调用自己

**调用栈**：用于存储多个函数的变量

使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择。
- 重新编写代码，转而使用循环。
- 使用**尾递归** 。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言都支持尾递归。

# 第4章 快速排序

分而治之：divide and conquer

划分土地的问题，将一块地均匀地分成方块，并确保分出的方块是最大。
**适用于这小块地的最大方块，也是适用于整块地的最大方块**（欧几里得算法）
D&C的工作原理：
- 找出基线条件（什么时候停止）
- 确定如何缩小问题的规模，使其符合基线条件

既然使用循环可轻松地完成任务，为何还要使用递归方式呢？看看函数式编程你就明白了！诸如Haskell等函数式编程语言没有循环，因此你只能使用递归来编写这样的函数。

**快速排序原理：**
- 选基准值
- 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
- 对这两个子数组进行快速排序。

归纳证明法：分两步：基线条件和归纳条件

快速排序的代码：
```python
def quicksort(array):
  if len(array) < 2:
    return array  ←------基线条件：为空或只包含一个元素的数组是“有序”的
  else:
    pivot = array[0]  ←------递归条件
    less = [i for i in array[1:] if i <= pivot]  ←------由所有小于基准值的元素组成的子数组

    greater = [i for i in array[1:] if i > pivot]  ←------由所有大于基准值的元素组成的子数组

    return quicksort(less) + [pivot] + quicksort(greater)

print quicksort([10, 5, 2, 3])
```

快速排序的独特之处在于，其速度取决于选择的基准值。
- 在平均情况下，快速排序的运行时间为_O_ (_n_ log _n_ )，每次都分成了一份
- ![[file-20251110185035066.jpg | 300]]
- 在最糟情况下，其运行时间为_O_ (_n_ 2 )，每次都分成了两份
![[file-20251110185052820.jpg | 350]]
有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。

# 第5章 散列表

杂货店商品价格表的例子引出散列函数，时间复杂度为O（1）

散列函数能够精准找到的关键原因：
- 将同样的输入映射到相同的索引
- 不同的输入映射到不同的索引
- 散列函数知道数组有多大，只返回有效的索引

Python提供的散列表实现为字典，你可使用**函数dict**来创建散列表。

散列表的场景：电话簿、DNS转换、防重、缓存

冲突：给两个键分配的位置相同。

- **散列函数很重要**：前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。

散列表平均操作运行时间O(1)、最糟糕O(n)

填装因子=散列表包含的元素数/位置总数

填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。

# 第6章 广度优先搜索

通过金门大桥的例子引入最短路径问题，解决最短路径问题的算法被称为**广度优先搜索** 。

图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为**邻居**。

广度优先搜索解决两类问题：
- 有没有路径
- 哪条路径最短
一度关系优先于二度关系，需要按添加顺序进行检查。有一个可实现这种目的的数据结构，那就是**队列** （queue）。

队列是一种**先进先出** （First In First Out，FIFO）的数据结构，而栈是一种**后进先出** （Last In First Out，LIFO）的数据结构。

散列表可以表示映射关系。
![[file-20251117221550663.jpg | 400]]
```python 
graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []
```

![[file-20251117222221046.jpg | 450]]
可以出队可以入队，在Python中，可使用函数deque来创建一个双端队列。
```python
from collections import deque
search_queue = deque()  ←------------创建一个队列
search_queue += graph["you"]  ←------将你的邻居都加入到这个搜索队列中

while search_queue:  ←------只要队列不为空
    person = search_queue.popleft()  ←------就取出其中的第一个人
    if person_is_seller(person):  ←------检查这个人是否是芒果销售商
        print person + " is a mango seller!"  ←------是芒果销售商
        return True
    else:
        search_queue += graph[person]  ←------不是芒果销售商。将这个人的朋友都加入搜索队列
return False  ←------如果到达了这里，就说明队列中没人是芒果销售商

def person_is_seller(name):
    return name[-1] == 'm'

```

如果有环，将形成无限循环，所以需要使用一个列表来记录检查过的人
```python
def search(name):
    search_queue = deque()
    search_queue += graph[name]
    searched = []  ←------------------------------这个数组用于记录检查过的人
    while search_queue:
        person = search_queue.popleft()
        if person not in searched:     ←----------仅当这个人没检查过时才检查
            if person_is_seller(person):
                print person + " is a mango seller!"
                return True
            else:
                search_queue += graph[person]
                searched.append(person)    ←------将这个人标记为检查过
    return False


search("you")
```

广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V+ E)，其中V为顶点（vertice）数，E为边数。

# 第7章 狄克斯特拉算法

加权图，狄克斯特拉算法可以帮忙找到最短路径，环会导致该算法不可用

![[file-20251118232349574.jpg | 500]]

(1) 找出最便宜的节点，即可在最短时间内前往的节点。
(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。
(3) 重复这个过程，直到对图中的每个节点都这样做了。
(4) 计算最终路径。（下一节再介绍！）

加权图、非加权图，要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法 。

狄克斯特拉算法只适用于**有向无环图**（directed acyclic graph，DAG）。

通过乐谱换吉他的例子，执行该算法：
狄克斯特拉算法背后的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径！
如果有负权边，就不能使用狄克斯特拉算法

不能将狄克斯特拉算法用于包含负权边的图。在包含负权边的图中，要找出最短路径，可使用另一种算法——**贝尔曼-福德算法**（Bellman-Ford algorithm）。

代码实现：
![[file-20251118234056778.jpg | 500]]
```python
node = find_lowest_cost_node(costs)  ←------在未处理的节点中找出开销最小的节点
while node is not None:  ←------这个while循环在所有节点都被处理过后结束
    cost = costs[node]
    neighbors = graph[node]
    for n in neighbors.keys():  ←------遍历当前节点的所有邻居
        new_cost = cost + neighbors[n]
        if costs[n] > new_cost:  ←------如果经当前节点前往该邻居更近，
            costs[n] = new_cost  ←------就更新该邻居的开销
            parents[n] = node  ←------同时将该邻居的父节点设置为当前节点
            processed.append(node)  ←------将当前节点标记为处理过
    node = find_lowest_cost_node(costs)  ←------找出接下来要处理的节点，并循环
```

```python
def find_lowest_cost_node(costs):
    lowest_cost = float("inf")
    lowest_cost_node = None
    for node in costs:  ←------遍历所有的节点
        cost = costs[node]
        if cost < lowest_cost and node not in processed:  ←------如果当前节点的开销更低且未处理过，
            lowest_cost = cost  ←------就将其视为开销最低的节点
            lowest_cost_node = node
    return lowest_cost_nod
```