作者： Martin Kleppmann                        
阅读日期：20250811——20250830
学习网站：http://ddia.vonng.com/

# 第1章 算法简介

查字典的例子给出二分查找算法：
```python
def binarySearch(list,item):
	low = 0
	high = len(list)-1
	while low < high:
		mid = low + high / 2
		guess = list[mid]
		if guess == item:
			return mid
		if guess > item:
			high = mid - 1
		else:
			low = mid + 1
	return None
	
my_list=[1,2,5,6,8]
print binarySearch(my_list, 5)
```

大O表示法：

![[file-20251029205156987.jpg]]

旅行商问题——运行时间O(n!)的算法

涉及n个城市时，需要执行n !（n的阶乘）次操作才能计算出结果。因此运行时间为O(n!)，即阶乘时间。除非涉及的城市数很少。

**小节：**
- 二分查找的速度比简单查找快得多。O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
- 算法运行时间并不以秒为单位。
- 算法运行时间是从其增速的角度度量的。
- 算法运行时间用大O表示法表示。

# 第2章 选择排序

通过看电影选座引入数组、链表
通过歌单排序引入选择排序，时间复杂度O(n2)：

```python
def findSmallest(arr):
  smallest = arr[0]  ←------存储最小的值
  smallest_index = 0  ←------存储最小元素的索引
  for i in range(1, len(arr)):
    if arr[i] < smallest:
      smallest = arr[i]
      smallest_index = i
  return smallest_index
```

```python
def selectionSort(arr):  ←------对数组进行排序
  newArr = []
  for i in range(len(arr)):
      smallest = findSmallest(arr)  ←------找出数组中最小的元素，并将其加入到新数组中
      newArr.append(arr.pop(smallest))
  return newArr

print selectionSort([5, 3, 6, 2, 10])
```
# 第3章 选择排序

外祖母的钥匙问题，引入循环和递归的对比：
- 循环：
```python
def look_for_key(main_box):
  pile = main_box.make_a_pile_to_look_through()
  while pile is not empty:
    box = pile.grab_a_box()
    for item in box:
      if item.is_a_box():
        pile.append(item)
      elif item.is_a_key():
        print "found the key!"
```
- 递归
```python
def look_for_key(box):
  for item in box:
    if item.is_a_box():
      look_for_key(item)  ←------递归！
    elif item.is_a_key():
      print "found the key!"
```
“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”

**每个递归函数都有两部分：基线条件** （base case）**和递归条件** （recursive case）
- 递归条件：函数调用自己
- 基线条件：函数不再调用自己

**调用栈**：用于存储多个函数的变量

使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择。
- 重新编写代码，转而使用循环。
- 使用**尾递归** 。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言都支持尾递归。

# 第4章 快速排序

分而治之：divide and conquer

划分土地的问题，将一块地均匀地分成方块，并确保分出的方块是最大。
**适用于这小块地的最大方块，也是适用于整块地的最大方块**（欧几里得算法）
D&C的工作原理：
- 找出基线条件（什么时候停止）
- 确定如何缩小问题的规模，使其符合基线条件

既然使用循环可轻松地完成任务，为何还要使用递归方式呢？看看函数式编程你就明白了！诸如Haskell等函数式编程语言没有循环，因此你只能使用递归来编写这样的函数。

**快速排序原理：**
- 选基准值
- 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
- 对这两个子数组进行快速排序。

归纳证明法：分两步：基线条件和归纳条件

快速排序的代码：
```python
def quicksort(array):
  if len(array) < 2:
    return array  ←------基线条件：为空或只包含一个元素的数组是“有序”的
  else:
    pivot = array[0]  ←------递归条件
    less = [i for i in array[1:] if i <= pivot]  ←------由所有小于基准值的元素组成的子数组

    greater = [i for i in array[1:] if i > pivot]  ←------由所有大于基准值的元素组成的子数组

    return quicksort(less) + [pivot] + quicksort(greater)

print quicksort([10, 5, 2, 3])
```

快速排序的独特之处在于，其速度取决于选择的基准值。
- 在平均情况下，快速排序的运行时间为_O_ (_n_ log _n_ )，每次都分成了一份
- ![[file-20251110185035066.jpg | 300]]
- 在最糟情况下，其运行时间为_O_ (_n_ 2 )，每次都分成了两份
![[file-20251110185052820.jpg | 350]]
有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。

# 第5章 散列表

杂货店商品价格表的例子引出散列函数，时间复杂度为O（1）

散列函数能够精准找到的关键原因：
- 将同样的输入映射到相同的索引
- 不同的输入映射到不同的索引
- 散列函数知道数组有多大，只返回有效的索引

Python提供的散列表实现为字典，你可使用**函数dict**来创建散列表。

散列表的场景：电话簿、DNS转换、防重、缓存

冲突：给两个键分配的位置相同。

- **散列函数很重要**：前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。

散列表平均操作运行时间O(1)、最糟糕O(n)

填装因子=散列表包含的元素数/位置总数

填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。

# 第6章 广度优先搜索

通过金门大桥的例子引入最短路径问题，解决最短路径问题的算法被称为**广度优先搜索** 。

图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为**邻居**。

广度优先搜索解决两类问题：
- 有没有路径
- 哪条路径最短
一度关系优先于二度关系，需要按添加顺序进行检查。有一个可实现这种目的的数据结构，那就是**队列** （queue）。

队列是一种**先进先出** （First In First Out，FIFO）的数据结构，而栈是一种**后进先出** （Last In First Out，LIFO）的数据结构。


